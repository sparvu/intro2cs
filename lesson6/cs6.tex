\documentclass[aspectratio=1610]{beamer}
\usetheme{boxes}
\usecolortheme{crane}
\usepackage{amsmath,amsfonts}
\usepackage{algpseudocode}
\usepackage{multicol}
\usepackage{pgfplots}
\pgfplotsset{compat=1.15}
\usepackage{mathrsfs}
\usepackage{listings}
\lstset{
  columns=flexible
}
\usetikzlibrary{arrows}


%-------------------------------------------------------------------
%	 TITLE SLIDE
%-------------------------------------------------------------------


\begin{document}

% -------------------------------------------------------------------
% Lesson 6
% -------------------------------------------------------------------
\section{Build Safe and Secure Software}

\begin{frame}
\begin{center}
\Huge Lesson 6\\~\\
\textbf{Build Safe and Secure Software}
\end{center}
\end{frame}



\begin{frame}
\frametitle{Lesson 6}
\Huge In this lesson we will talk about:\\
\huge
\begin{itemize}
 \item \alert{Why modern software sucks}\\
 \item \alert{Software Testing}\\
 \item \alert{Static and Dynamic Analysis}\\
 \item \alert{CI/CD Pipelines}\\
 \item \alert{Testing is not enough}
\end{itemize}
\end{frame}


\begin{frame}{Lesson 6}{Safe and Secure Software}
\Huge
\begin{center}
Year 2025
\end{center}
\end{frame}


\begin{frame}{Lesson 6}{Safe and Secure Software}
\Huge
\begin{center}
We are drowning in security vulnerabilities, software defects and bugs! 
\end{center}
\end{frame}


\begin{frame}[plain,noframenumbering]
\makebox[\linewidth]{\includegraphics[width=\paperwidth]{Images/2025-securitybugs}}
\end{frame}


\begin{frame}{Lesson 6}{Safe and Secure Software}
\Huge
\begin{center}
More than 100 security vulnerabilities every single day!
\end{center}
\end{frame}



\begin{frame}{Lesson 6}{Safe and Secure Software}
\Huge
\begin{center}
May 2025\\~\\
\textbf{23\%\\
 increase compared to this time last year!}\\~\\ 
\large
Source: securityvulnerability.io/stats
\end{center}
\end{frame}


\begin{frame}[plain,noframenumbering]
\makebox[\linewidth]{\includegraphics[width=\paperwidth]{Images/secperyear}}
\end{frame}



\begin{frame}{Lesson 6}{Safe and Secure Software}
\Huge
\begin{center}
But we have SAFe, different agile methodologies, cloud computing and powerful computers, still cant produce safe and secure software\\
\textbf{Why?}
\end{center}
\end{frame}



\begin{frame}{Lesson 6}{Safe and Secure Software}
\Huge
\begin{center}
Some might say: we dont test enough or good enough. Some others, that we have developed 
too quickly, too much.
\end{center}
\end{frame}


\begin{frame}{Lesson 6}{Safe and Secure Software}
\Huge
\begin{center}
\textbf{The truth?}
\end{center}
\end{frame}


\begin{frame}[plain,noframenumbering]
\makebox[\linewidth]{\includegraphics[width=\paperwidth]{Images/guerrila_approach}}
\end{frame}



% %%%%%%%%%%%%%%%%%%
% Safe and Secure
% %%%%%%%%%%%%%%%%%%

\begin{frame}{Lesson 6}{Safe and Secure Software}
\LARGE
\textbf{Safe Software}\\
"Software safety is an engineering discipline that aims to ensure that software, which 
is used in critical related systems does not contribute to any hazards such a system 
might pose."
\begin{itemize}
    \item Automotive (ISO 26262), railway software (EN 50716)
    \item Airborne software (DO-178C/ED-12C)
    \item Air traffic management software (DO-278A/ED-109A)
    \item Medical devices (IEC 62304)
    \item Nuclear power plants (IEC 60880)
\end{itemize}
\end{frame}


\begin{frame}{Lesson 6}{Safe and Secure Software}
\LARGE
\textbf{System Safety}\\~\\
"System Safety aims to achieve safety by reducing risks in technical systems to an 
acceptable level." 
\end{frame}

\begin{frame}{Lesson 6}{Safe and Secure Software}
\LARGE
\textbf{System Safety}\\~\\
"Functional safety is achieved through engineering development to ensure correct 
execution and behavior of software functions as intended"
\end{frame}


\begin{frame}{Lesson 6}{Safe and Secure Software}
\LARGE
\textbf{System Safety}\\~\\
"Safety consistent with mission requirements, is designed into the software in a 
timely, cost effective manner."
\end{frame}


\begin{frame}{Lesson 6}{Safe and Secure Software}
\LARGE
\textbf{System Safety and AI}\\~\\
"Software that employs artificial intelligence techniques such as machine learning 
follows a radically different lifecycle. Currently, standards generally do not endorse 
their use. For example, EN 50716 states that artificial intelligence and machine 
learning are not recommended for any safety integrity level."
\end{frame}



\begin{frame}{Lesson 6}{Safe and Secure Software}
\LARGE
\textbf{Secure Software}\\
"Security is resilience against harm caused by others."
\begin{itemize}
    \item A threat
    \item DDOS atack
    \item Cryptojacking
    \item Man In The Middle (MITM) attacks
\end{itemize}
\end{frame}


\begin{frame}{Lesson 6}{Safe and Secure Software}
\LARGE
\textbf{Secure Software}\\
"Secure coding is the practice of developing computer software in such a way that 
guards against the accidental introduction of security vulnerabilities. Defects, bugs 
and logic flaws are consistently the primary cause of commonly exploited software 
vulnerabilities."
\end{frame}


\begin{frame}{Lesson 6}{Safe and Secure Software}
\LARGE
\textbf{Secure Software}\\
\begin{itemize}
	\item Buffer-overflow prevention
	\item Format-string attack prevention
	\item Integer-overflow prevention
	\item Path traversal prevention
\end{itemize}
\end{frame}



\begin{frame}{Lesson 6}{Safe and Secure Software}
\Huge
\begin{center}
Many IT organizations are currently working hard to adapt secure software development
life cycle for their products and services. Despite that the number of security
vulnerabilities is increasing
\end{center}
\end{frame}






% %%%%%%%%%%%%%%%%%%
% Software Testing
% %%%%%%%%%%%%%%%%%%

\begin{frame}{Lesson 6}{Safe and Secure Software}
\Huge
\begin{center}
Software Testing
\end{center}
\end{frame}



\begin{frame}{Lesson 6}{Safe and Secure Software}
\LARGE
\textbf{Software Testing}\\~\\
Software testing is the act of checking whether our software satisfies certain 
expectations. 
\end{frame}

\begin{frame}{Lesson 6}{Safe and Secure Software}
\LARGE
\textbf{Software Testing}\\~\\
It is all about finding bugs. Bug = a defect in the code that causes an undesirable 
result. Bugs generally slow testing progress and involve programmer assistance to debug 
and fix.
\end{frame}

\begin{frame}{Lesson 6}{Safe and Secure Software}
\LARGE
\textbf{Software Testing}\\~\\
\textbf{But not all defects cause a failure}. For example, a defect in dead code will 
not be considered a failure. Or a defect in the rendering the user manual documentation 
will not cause a general failure of the application.
\end{frame}



\begin{frame}{Lesson 6}{Safe and Secure Software}
\Huge
\begin{center}
So, we must know where and what to look.
\end{center}
\end{frame}



\begin{frame}{Lesson 6}{Safe and Secure Software}
\LARGE
\textbf{Software Testing}\\~\\
Software testing can determine \textbf{the correctness} of software for specific 
scenarios but cannot determine correctness for \textbf{all} scenarios.\\~\\
In other words, it cannot find \textbf{all} bugs.
\end{frame}



\begin{frame}{Lesson 6}{Safe and Secure Software}
\LARGE
\textbf{Software Testing}\\~\\
So, by definition software testing already is telling us we cannot cover all possible 
situations to test. Despite that, many IT organizations believe testing alone can
achieve that.
\end{frame}


\begin{frame}{Lesson 6}{Safe and Secure Software}
{\LARGE\textbf{{Is testing enough?}}}\\
\Large
\begin{minipage}{0.50\textwidth}
    \begin{itemize}
      \item Start testing your software
      \item Write different test cases
      \item Automate
      \item But testing will not be enough
      \item Go back to specifications
    \end{itemize}
  \end{minipage}
\begin{minipage}{0.4\textwidth}
    % Show the image at item three and afterwards
      \begin{figure}
        \includegraphics[scale=0.05]{Images/guerrila}
      \end{figure}
  \end{minipage}  
\end{frame}



\begin{frame}{Lesson 6}{Safe and Secure Software}
\LARGE
\textbf{Software Testing}\\~\\
What can we do about it? Is it even possible to test all possible cases, or simple does 
not matter?
\end{frame}



\begin{frame}{Lesson 6}{Safe and Secure Software}
\Huge
\begin{center}
The correct answer:\\
\textbf{It depends!}
\end{center}
\end{frame}


\begin{frame}{Lesson 6}{Safe and Secure Software}
\Huge
\begin{center}
If you are building a complex application or algorithm, 
used in a business or mission critical installation\\
\textbf{YES}\\
You must think of \textbf{ALL} possible cases
\end{center}
\end{frame}



\begin{frame}{Lesson 6}{Safe and Secure Software}
\Huge
\begin{center}
In other words if your software is a business or mission 
critical application - \textbf{YES} - you must think how can you test
your specs for ALL possible cases.
\end{center}
\end{frame}



\begin{frame}{Lesson 6}{Safe and Secure Software}
\Huge
\begin{center}
The more critical your algorithm, application, pipeline is, the more you must be aware 
how correctly it runs and it is implemented.
\end{center}
\end{frame}



\begin{frame}{Lesson 6}{Safe and Secure Software}
\Huge
\begin{center}
\textbf{But how can you do that? And what does it really mean to test ALL possible 
cases?}
\end{center}
\end{frame}



\begin{frame}{Lesson 6}{Safe and Secure Software}
\LARGE
\textbf{Software Testing}\\~\\ 
\begin{itemize}
    \item Functional Testing
    \item Non-Functional Testing
\end{itemize}
\end{frame}



\begin{frame}{Lesson 6}{Safe and Secure Software}
\LARGE
\textbf{Functional Testing}\\~\\ 
It is a software system testing that verifies whether a system or application meets its 
\alert{functional requirements or specifications}. 
\end{frame}



\begin{frame}{Lesson 6}{Safe and Secure Software}
\huge
Remember this?\\~\\
A \textbf{functional software specification} is a \alert{written} description of what 
our program is supposed to do.
\end{frame}


\begin{frame}{Lesson 6}{Safe and Secure Software}
\includegraphics[scale=0.41]{Images/funcspecs}
\end{frame}


\begin{frame}{Lesson 6}{Safe and Secure Software}
\LARGE
\textbf{Functional Testing}\\~\\ 
\begin{itemize}
    \item Unit Testing
    \item Integration System Testing
    \item Regression Testing
    \item Smoke Testing
    \item Usability Testing
\end{itemize}
\end{frame}



\begin{frame}{Lesson 6}{Safe and Secure Software}
\LARGE
\textbf{Unit Testing}\\~\\ 
It is a component or module testing, where we are testing a part of our software only 
to ensure it is bug free. 
\begin{itemize}
    \item we test a very simple part
    \item can be a function or a method
    \item can be automated 
    \item or manually executed
\end{itemize}
\end{frame}


\begin{frame}{Lesson 6}{Safe and Secure Software}
\Huge
\begin{center}
Unit testing is intended to ensure that the units meet their design and behave as 
intended. 
\end{center}
\end{frame}


\begin{frame}{Lesson 6}{Safe and Secure Software}
\LARGE
\textbf{Unit Testing}\\~\\ 
Unit testing finds problems early in the development cycle. This includes both bugs in 
the programmer's implementation and flaws or missing parts of the specification for the 
unit.
\end{frame}

\begin{frame}{Lesson 6}{Safe and Secure Software}
\LARGE
\textbf{Unit Testing}\\~\\ 
The process of writing a thorough set of tests forces the author to think through 
inputs, outputs, and error conditions, and thus more crisply define the unit's desired 
behavior.
\end{frame}

\begin{frame}{Lesson 6}{Safe and Secure Software}
\LARGE
\textbf{Non-functional Testing}\\~\\ 
Non-functional testing is testing software for its non-functional requirements: the way 
a system or application operates: does it use a lot of computing resources ... 
\end{frame}


\begin{frame}{Lesson 6}{Safe and Secure Software}
\LARGE
\textbf{Functional Testing}\\~\\ 
\begin{itemize}
    \item Endurance Testing
    \item Performance Testing
    \item Scalability Testing
    \item Stress Testing
\end{itemize}
\end{frame}



% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Static and Dynamic Analysis
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Lesson 6}{Safe and Secure Software}
\Huge
\begin{center}
Static and Dynamic Analysis
\end{center}
\end{frame}


\begin{frame}{Lesson 6}{Safe and Secure Software}
\LARGE
\textbf{Static vs Dynamic Analysis}\\~\\ 
Static program analysis is the analysis of computer programs performed without
executing them, in contrast with dynamic program analysis, which is performed on 
programs during their execution in the integrated environment.
\end{frame}



% %%%%%%%%%%%%%%%%
% CICD Pipelines
% %%%%%%%%%%%%%%%%

\begin{frame}{Lesson 6}{Safe and Secure Software}
\Huge
\begin{center}
CICD Pipelines
\end{center}
\end{frame}


\begin{frame}{Lesson 6}{Safe and Secure Software}
\LARGE
\textbf{CICD}\\~\\ 
CICD = continuous integration (CI) and continuous delivery (CD) or, less often,
continuous deployment (CD).
\end{frame}

\begin{frame}{Lesson 6}{Safe and Secure Software}
\LARGE
\textbf{CI}\\~\\ 
Continuous integration (CI) is the practice of integrating source code changes 
frequently and ensuring that the integrated codebase is in a workable state.
\end{frame}



\begin{frame}{Lesson 6}{Safe and Secure Software}
\LARGE
\textbf{CD - Delivery}\\~\\
Continuous delivery (CD) is a software engineering approach in which teams produce 
software in short cycles, ensuring that the software can be reliably released at any 
time.
\end{frame}

\begin{frame}{Lesson 6}{Safe and Secure Software}
\LARGE
\textbf{CD - Delivery}\\~\\
It aims at building, testing, and releasing software with greater speed and frequency.
The approach helps reduce the cost, time,[citation needed] and risk of delivering
changes by allowing for more incremental updates to applications in production.
\end{frame}


\begin{frame}{Lesson 6}{Safe and Secure Software}
\LARGE
\textbf{CD - Deployment}\\~\\
Continuous deployment (CD) is a software engineering approach in which software 
functionalities are delivered frequently and through automated deployments.
\end{frame}



\begin{frame}{Lesson 6}{Safe and Secure Software}
\LARGE
\textbf{CD - Deployment}\\
Continuous deployment contrasts with continuous delivery (also CD), a 
similar approach in which software functionalities are also frequently delivered and 
deemed to be potentially capable of being deployed, but are actually not deployed. 
As such, continuous deployment can be viewed as a more complete form of automation than 
continuous delivery
\end{frame}




\begin{frame}[plain,noframenumbering]
\makebox[\linewidth]{\includegraphics[width=\paperwidth]{Images/secperyear}}
\end{frame}


\begin{frame}{Lesson 6}{Safe and Secure Software}
\LARGE
\textbf{Software Testing}\\~\\
Software testing can determine \textbf{the correctness} of software for specific 
scenarios but cannot determine correctness for \textbf{all} scenarios.\\~\\
In other words, it cannot find \textbf{all} bugs.
\end{frame}



\begin{frame}{Lesson 6}{Safe and Secure Software}
\Huge
\begin{center}
Testing alone is NOT enough
\end{center}
\end{frame}



\begin{frame}{Lesson 6}{Safe and Secure Software}
\Huge
\begin{center}
Testing vs Proving
\end{center}
\end{frame}



\begin{frame}{Lesson 6}{Safe and Secure Software}
\Huge
\begin{center}
How can we proof our code (algorithm) is correct?
\end{center}
\end{frame}


\begin{frame}{Lesson 6}{Safe and Secure Software}
\Huge
\begin{center}
\textbf{Formal methods}
\end{center}
\end{frame}


\begin{frame}{Lesson 6}{Safe and Secure Software}
\LARGE
\textbf{Formal methods}\\~\\
A collection of different math techniques to conduct technically and functional proofs
\begin{itemize}
    \item mathematical guarantee of absence of bugs or vulnerabilities
    \item mathematical guarantee that the code functionally behaves as per its specs
    \item or manually executed
\end{itemize}
\end{frame}



\begin{frame}{Lesson 6}{Safe and Secure Software}
\LARGE
\textbf{Formal methods}\\~\\
\begin{itemize}
    \item Similar to Static Analysis
    \item Much deeper analysis
    \item or manually 
\end{itemize}
\end{frame}


\begin{frame}{Lesson 6}{Safe and Secure Software}
\Huge
\begin{center}
Without \textbf{Formal methods} we cannot guarantee the correctness of our algorithm
and code!
\end{center}
\end{frame}


\end{document}

